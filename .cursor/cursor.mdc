---
description: "Complete Cursor 2.4 native tools reference: search, edit, run, subagents, skills, and advanced features for agentic workflows"
alwaysApply: false
---

# Cursor 2.4 Tools Mastery

Complete reference for all Cursor 2.4 tools including native subagents, Agent Skills, and advanced features.

## CRITICAL: Agentic-First Tool Usage

### The Golden Rule: Verify Before You Act

Every action follows this pattern:
1. **CHECK** - What exists? What's the current state?
2. **VERIFY** - What versions? What's available?
3. **ACT** - Make the change using proper tools
4. **VALIDATE** - Did it work? Any errors?

### Pre-Action Verification Protocol

Before ANY significant action:

```
BEFORE CREATING PROJECT:
1. Check if CLI tool exists: Shell(command="which flutter")
2. Check CLI version: Shell(command="flutter --version")
3. Web search for current version: WebSearch(search_term="Flutter stable February 2026") — use actual date from context
4. Check if project already exists: LS(target_directory="./")

BEFORE INSTALLING PACKAGES:
1. Check package.json/pubspec.yaml exists: Read(path="package.json")
2. Check if already installed: Read(path="package-lock.json")
3. Verify package name/version: WebSearch(search_term="lodash npm latest version")

BEFORE EDITING CODE:
1. Read the file first: Read(path="src/component.tsx")
2. Understand context and dependencies
3. Check for related files that might need updating
```

### Proactive Web Search Usage

**ALWAYS use WebSearch for:**
- Package versions before installing
- Framework syntax when unsure
- Error messages you encounter
- API documentation verification
- Current best practices

**Search Pattern:** Replace placeholders with actual values from context (e.g., user_info date). Use concrete dates like "February 2026", not literal `[current month] [current year]`.
```
WebSearch(search_term="[package/framework] [specific feature] [actual month/year]")
```

Examples:
- `WebSearch(search_term="Next.js App Router server actions February 2026")` — use concrete date
- `WebSearch(search_term="React 19 useFormStatus hook syntax")`
- `WebSearch(search_term="shadcn ui button component installation")`

---

## Search Tools

### `Read`
**Purpose**: Read file contents with line numbers

**When to Use**:
- Examining specific files
- Understanding code structure
- Reviewing implementations
- Checking configurations

**Best Practices**:
- Read whole files unless very large (>1000 lines)
- Use `offset` and `limit` for large files
- Batch multiple file reads in parallel
- Check imports and dependencies

**Example Usage**:
```
Read the main entry point to understand the application structure
→ Read(path="src/index.ts")
```

---

### `LS`
**Purpose**: List directory contents

**When to Use**:
- Exploring project structure
- Finding files in a directory
- Understanding folder organization
- Discovering available modules

**Best Practices**:
- Start at project root for orientation
- Use `ignore_globs` to filter noise (node_modules, etc.)
- Navigate progressively deeper

**Example Usage**:
```
Explore the project structure
→ LS(target_directory=".", ignore_globs=["node_modules", ".git"])
```

---

### `SemanticSearch`
**Purpose**: Semantic search - finds code by meaning, not exact text

**When to Use**:
- Finding implementations by concept
- Locating where behavior is defined
- Understanding how features work
- Exploring unfamiliar codebases

**When NOT to Use**:
- Exact text matches (use `Grep`)
- Simple symbol lookups (use `Grep`)
- Finding files by name (use `Glob`)

**Best Practices**:
- Ask complete questions: "Where is user authentication handled?"
- One question per search (don't combine multiple queries)
- Start broad, then narrow to specific directories
- Use for "how/where/what" questions

**Example Usage**:
```
Find where API routes are defined
→ SemanticSearch(query="Where are the API routes defined?", target_directories=["src/"])
```

---

### `Grep`
**Purpose**: Regex-based text search (powered by ripgrep)

**When to Use**:
- Exact symbol/string searches
- Finding function calls
- Locating imports/exports
- Counting occurrences

**Parameters**:
- `pattern`: Regex pattern to search
- `path`: Directory or file to search
- `type`: File type filter (js, py, rs, go, etc.)
- `glob`: Custom glob pattern
- `-C`, `-A`, `-B`: Context lines
- `output_mode`: "content", "files_with_matches", or "count"

**Best Practices**:
- Escape special regex characters: `functionCall\(`
- Use `output_mode: "files_with_matches"` to find all relevant files
- Add context with `-C 3` to understand surrounding code

**Example Usage**:
```
Find all uses of a specific function
→ Grep(pattern="useAuth\\(", path="src/", type="ts")

Find files containing a pattern
→ Grep(pattern="TODO:", output_mode="files_with_matches")
```

---

### `Glob`
**Purpose**: Find files by name pattern

**When to Use**:
- Locating files by extension
- Finding configuration files
- Discovering test files
- Matching naming conventions

**Best Practices**:
- Patterns auto-prepend `**/` for recursive search
- Use for file discovery, not content search

**Example Usage**:
```
Find all test files
→ Glob(glob_pattern="*.test.ts")

Find configuration files
→ Glob(glob_pattern="*.config.*")
```

---

### `WebSearch`
**Purpose**: Search the internet for real-time information

**When to Use**:
- Current documentation
- Recent solutions
- Security advisories
- Version-specific information

**Best Practices**:
- Include version numbers if relevant
- Add dates for time-sensitive queries
- Use specific keywords

**Proactive Usage**: Don't wait for "Ask" mode - use `WebSearch` proactively in Agent mode when:
- You need current information about libraries or APIs
- Error messages suggest version-specific issues
- User asks about recent features or changes

---

## MCP Tools Invocation

Cursor exposes MCP (Model Context Protocol) tools via `call_mcp_tool(server, toolName, arguments)`. **Always check the tool schema/descriptor before calling** — schemas live in the project's `mcps/<server>/tools/` folder.

**Invocation pattern:**
```
→ call_mcp_tool(
    server="cursor-ide-browser",
    toolName="browser_navigate",
    arguments={ "url": "http://localhost:3000" }
  )
```

**Critical**: List and read the tool's JSON descriptor in `mcps/<server>/tools/` to get exact parameter names and types before calling.

---

## Browser Tools

Cursor provides browser tools via the `cursor-ide-browser` MCP server for testing and interacting with web applications. Tools may appear as native tools or require `call_mcp_tool(server="cursor-ide-browser", toolName="...", arguments={...})`.

### CRITICAL: Browser Lock/Unlock Workflow

1. **browser_lock requires an existing browser tab** — you CANNOT lock before browser_navigate
2. **Correct order**: `browser_navigate` → `browser_lock` → (interactions) → `browser_unlock`
3. **If a tab already exists**: Check with `browser_tabs` (action: "list"), then call `browser_lock` FIRST before any interactions
4. **browser_unlock**: Only call when completely done with ALL browser operations for this turn

### `browser_navigate`
**Purpose**: Navigate to a URL

**When to Use**:
- Testing web application features
- Verifying UI implementations
- Checking deployed changes

### `browser_snapshot`
**Purpose**: Capture accessibility snapshot of current page

**When to Use**:
- Understanding page structure
- Finding elements to interact with
- Better than screenshots for element identification

**Best Practices**:
- Call snapshot BEFORE clicking/typing to get element refs
- Use returned refs for subsequent interactions

### `browser_click`
**Purpose**: Click on web page elements

**Parameters**:
- `element`: Human-readable element description
- `ref`: Exact target element reference from snapshot
- `button`: Button to click (defaults to left)
- `doubleClick`: Whether to double-click

### `browser_type`
**Purpose**: Type text into editable elements

**Parameters**:
- `element`: Human-readable element description
- `ref`: Exact target element reference from snapshot
- `text`: Text to type
- `submit`: Whether to press Enter after typing
- `slowly`: Type one character at a time (for key handlers)

### `browser_hover`
**Purpose**: Hover over elements (for tooltips, dropdowns)

### `browser_select_option`
**Purpose**: Select options in dropdowns

### `browser_press_key`
**Purpose**: Press keyboard keys (e.g., ArrowLeft, Enter, Escape)

### `browser_wait_for`
**Purpose**: Wait for conditions

**Parameters**:
- `text`: Wait for text to appear
- `textGone`: Wait for text to disappear
- `time`: Wait for specified seconds

### `browser_navigate_back`
**Purpose**: Go back to previous page

### `browser_resize`
**Purpose**: Resize browser window for responsive testing

### `browser_console_messages`
**Purpose**: Get all console messages (errors, warnings, logs)

**When to Use**:
- Debugging JavaScript errors
- Checking for runtime issues
- Verifying console output

### `browser_network_requests`
**Purpose**: Get all network requests since page load

**When to Use**:
- Debugging API calls
- Verifying request/response data
- Checking for failed requests

### `browser_tabs`
**Purpose**: List open tabs (action: "list") — use before lock to check if a tab exists

### `browser_fill`
**Purpose**: Clear and replace text in editable elements (unlike `browser_type` which appends)

### `browser_scroll`
**Purpose**: Scroll elements into view — use `scrollIntoView: true` for nested scroll containers before clicking obscured elements

### `browser_handle_dialog`
**Purpose**: Handle native dialogs (alert/confirm/prompt) — call BEFORE the triggering action. Use `accept: false` for Cancel, `promptText` for custom prompt input

### `browser_profile_start` / `browser_profile_stop`
**Purpose**: CPU profiling — profile data in `~/.cursor/browser-logs/` (cpu-profile-*.json, cpu-profile-*-summary.md). Read raw JSON to verify summary findings

**Limitation**: Iframe content is not accessible — only elements outside iframes can be interacted with

### Browser Testing Workflow

```
1. Check existing tabs (if any): browser_tabs(action="list")
2. Navigate to the page: browser_navigate(url="http://localhost:3000")
3. Lock the tab: browser_lock (required before interactions)
4. Snapshot to get elements: browser_snapshot()
5. Interact using refs from snapshot: browser_click(element="Submit button", ref="btn-submit")
6. Wait for changes if needed: browser_wait_for(text="Success") or short waits (1-3s) with snapshot checks
7. Snapshot again to verify: browser_snapshot()
8. Check console/network: browser_console_messages(), browser_network_requests()
9. Unlock when done: browser_unlock
```

**Waiting strategy**: Prefer short incremental waits (1-3 seconds) with browser_snapshot checks in between rather than one long wait.

### Proactive Browser Usage

Don't wait for explicit requests - use browser tools proactively when:
- You've implemented a UI feature → test it immediately
- User reports a visual bug → navigate and inspect
- You need to verify API integrations → check network requests
- You're debugging frontend issues → check console messages

---

## Edit Tools

### `StrReplace`
**Purpose**: Exact string replacement in files

**When to Use**:
- Modifying existing code
- Updating function implementations
- Fixing bugs in specific locations
- Renaming with `replace_all: true`

**CRITICAL Rules**:
- `old_string` must be UNIQUE in the file
- Include enough context (3-5 lines before/after)
- Match exact whitespace and indentation
- Preserve original indentation style

**Best Practices**:
- Read the file first to ensure accurate matching
- Include surrounding context for uniqueness
- Use `replace_all: true` for renaming operations
- Make atomic, focused changes

**Example Usage**:
```
Update a function implementation
→ StrReplace(
    path="src/utils.ts",
    old_string="function oldImpl() {\n  return 1;\n}",
    new_string="function oldImpl() {\n  return 2;\n}"
  )
```

---

### `Write`
**Purpose**: Create or overwrite entire files

**When to Use**:
- Creating new files
- Complete file rewrites
- Generating new modules
- Writing configuration files

**Best Practices**:
- ALWAYS read existing files before overwriting
- Prefer `StrReplace` for modifications
- Include all necessary imports
- Follow project conventions

---

### `Delete`
**Purpose**: Remove files from the project

**When to Use**:
- Cleanup during refactoring
- Removing deprecated code
- Deleting generated files

---

### `EditNotebook`
**Purpose**: Edit Jupyter notebook cells

**When to Use**:
- Data science notebooks
- Interactive Python development
- Documentation notebooks

**Best Practices**:
- Set `is_new_cell` correctly
- Use 0-based cell indices
- Provide unique `old_string` for edits

---

## Run Tools

### `Shell`
**Purpose**: Execute shell commands

**When to Use**:
- Building projects
- Running tests
- Installing dependencies
- Executing scripts
- Git operations

**Parameters**:
- `command`: The command to execute
- `description`: Brief description of what the command does
- `is_background`: For long-running processes
- `timeout`: Timeout in milliseconds
- `working_directory`: Directory to run command in

**Best Practices**:
- Use `is_background: true` for long-running processes
- Check existing terminals before starting servers (see Terminals Folder Pattern below)
- Use non-interactive flags (`--yes`, `-y`, etc.)
- Always provide a clear `description`

**Terminals Folder Pattern** — Before starting dev servers, avoid duplicate processes:
1. List the terminals folder (project-specific path, e.g. under `.cursor` or Cursor project metadata)
2. Read terminal files to see `current command`, `cwd`, and `last_command`
3. Only start `npm run dev` / `flutter run` / etc. if no matching process is already running

**Example Usage**:
```
Install dependencies
→ Shell(command="npm install", description="Install dependencies")

Run tests
→ Shell(command="npm test", description="Run tests")

Start dev server in background
→ Shell(command="npm run dev", is_background=true, description="Start dev server")
```

---

### `ReadLints`
**Purpose**: Read linter errors from workspace

**When to Use**:
- After making edits
- Before committing changes
- Debugging type errors
- Checking code quality

**Best Practices**:
- Only call on files you've edited
- Fix errors before proceeding
- Don't call with wide scope

**Example Usage**:
```
Check lints after editing
→ ReadLints(paths=["src/components/Button.tsx"])
```

---

## MCP Tools

MCP (Model Context Protocol) tools extend Cursor's capabilities with external services. Use `call_mcp_tool(server, toolName, arguments)` for MCP invocation. **Always check the tool schema in `mcps/<server>/tools/` before calling.**

### mcp_web_fetch

**Purpose**: Fetch URL content and return it as readable markdown. Use for docs, API references.

**When to Use**:
- Official documentation (e.g., https://nextjs.org/docs)
- API references
- Verifying deployment URLs

**Parameters**: `url` — the fully-formed URL to fetch

**Limitations**: No authentication support; localhost and private IPs will not work (fetch runs from isolated server).

**Example**:
```
→ mcp_web_fetch(url="https://nextjs.org/docs/app/building-your-application/routing")
```

### fetch_mcp_resource / list_mcp_resources

**Purpose**: Fetch or list resources from MCP servers (e.g., documentation, assets). Use `list_mcp_resources` to discover available resources, then `fetch_mcp_resource(server, uri)` to retrieve content. Optional `downloadPath` saves to workspace.

### MiniMax MCP Tools
If configured, provides:
- `user-MiniMax-web_search`: Web search with current date context
- `user-MiniMax-understand_image`: Image analysis with VLM

### Context7 MCP Tools
If configured, provides:
- `user-context7-resolve-library-id`: Find library IDs
- `user-context7-query-docs`: Fetch up-to-date documentation

**CRITICAL**: Always check if MCP tools are available before using. Fall back to Cursor's native `WebSearch` if MiniMax MCP is not configured.

---

## Native Subagents (Cursor 2.4)

Cursor 2.4 introduces native subagents - independent agents with isolated context windows.

### Built-in Subagents

These activate automatically when appropriate:

| Subagent | Purpose | When Used |
|----------|---------|-----------|
| **explore** | Codebase search and analysis | Finding code, understanding structure |
| **bash** | Shell command sequences | Running multiple commands |
| **browser** | Web automation via MCP | Testing UI, browser interactions |

**You don't invoke these directly** - the agent delegates automatically.

### Custom Subagents

Define in `.cursor/agents/` (project) or `~/.cursor/agents/` (user):

```markdown
---
name: verifier
description: Validates completed work. Use after tasks marked done.
model: fast
---

You are a skeptical validator...
```

**Invoke explicitly**: `/verifier check the auth implementation`

### Task Tool (Programmatic Delegation)

For explicit subagent delegation:

```
→ Task(
    subagent_type="explore",  // or "generalPurpose"
    model="fast",
    prompt="Find all authentication-related files",
    description="Find auth files"
  )
```

---

## Agent Skills (Cursor 2.4)

Skills are portable packages of domain knowledge.

### Skill Locations

| Location | Scope |
|----------|-------|
| `.cursor/skills/` | Project-level |
| `~/.cursor/skills/` | User-level (global) |

### Skill Structure

```
.cursor/skills/
└── deploy-app/
    ├── SKILL.md          # Required
    ├── scripts/          # Optional - executable code
    └── references/       # Optional - detailed docs
```

### Invoking Skills

**Automatic**: Agent discovers based on context and description.

**Explicit**: Use `/skill-name` in chat:
```
> /deploy-app deploy to staging
> /migrate-to-skills convert my rules
```

### Built-in Migration Skill

Cursor 2.4 includes `/migrate-to-skills` to convert dynamic rules to skills.

---

## Tool Selection Decision Tree

```
Need to find code?
├─ By meaning/concept → SemanticSearch
├─ Exact text/symbol → Grep
├─ By filename → Glob
└─ Complex exploration → Native explore subagent (automatic)

Need to read?
├─ File contents → Read
├─ Directory structure → LS
└─ Linter errors → ReadLints

Need to edit?
├─ Modify existing → StrReplace
├─ Create new file → Write
├─ Remove file → Delete
└─ Jupyter notebook → EditNotebook

Need to execute?
├─ Single command → Shell
├─ Command sequence → Native bash subagent (automatic)
└─ MCP tool → Use MCP tool directly

Need external info?
├─ Real-time data → WebSearch (Cursor native)
├─ MiniMax search → user-MiniMax-web_search (if configured)
└─ Image analysis → user-MiniMax-understand_image (if configured)

Need to test web UI?
├─ Navigate/interact → Native browser subagent (automatic)
├─ Or manually:
│   ├─ Navigate → browser_navigate
│   ├─ Snapshot → browser_snapshot
│   └─ Interact → browser_click / browser_type

Need specialized work?
├─ Validate completed work → /verifier custom subagent
├─ Debug errors → /debugger custom subagent
├─ Domain knowledge → Invoke skill with /skill-name
└─ Programmatic delegation → Task tool
```

### Subagents vs Skills vs Task Tool

| Need | Solution |
|------|----------|
| Codebase exploration | Native `explore` (automatic) |
| Shell command sequences | Native `bash` (automatic) |
| Browser testing | Native `browser` (automatic) |
| Validate work | Custom subagent `/verifier` |
| Domain-specific knowledge | Skill `/skill-name` |
| Programmatic agent launch | Task tool |

## Parallel vs Sequential Tool Calls

### Use Parallel Calls When:
- Reading multiple independent files
- Searching different directories
- Making independent edits
- Gathering unrelated information

### Use Sequential Calls When:
- Results inform next parameters
- Order matters (create before edit)
- Dependencies between operations
- Validation needed before proceeding

### Example Parallel Pattern:
```
Reading multiple files simultaneously:
→ Read(path="src/index.ts")
→ Read(path="src/config.ts")
→ Read(path="package.json")
[All called in single batch]
```

## Cursor 2.4 Advanced Features

### Native Subagents
- **explore**: Codebase search with isolated context
- **bash**: Shell command execution with output filtering
- **browser**: Web automation via MCP with DOM filtering
- Custom subagents in `.cursor/agents/`

### Agent Skills
- Portable knowledge packages in `.cursor/skills/`
- Auto-discovery or `/skill-name` invocation
- Progressive loading (scripts, references, assets)
- Migration: `/migrate-to-skills`

### Debug Mode
- Instruments apps with runtime logs
- Helps reproduce complex bugs
- Works across stacks and languages

### Browser Layout Editor
- Real-time CSS/layout editing
- Component tree visualization
- Integrated with codebase

### Plan Mode + Mermaid
- Visual planning with diagrams
- Send to-dos to new agents
- Structured task management

### Multi-Agent Features
- Parallel subagents with isolated context
- Background subagents (`is_background: true`)
- Multi-agent judging for comparing solutions

### Image Generation
- Generate images directly from agent
- Saved to `assets/` folder by default
- Useful for mockups and diagrams

---

## CRITICAL: What NEVER To Do

### Never Manually Create These Files

These files are generated by CLIs and should NEVER be created manually:

| File Type | Use CLI Instead |
|-----------|----------------|
| `package.json` | `npm init` or `pnpm init` |
| `package-lock.json` | Generated by `npm install` |
| `go.mod` | `go mod init` |
| `Cargo.toml` | `cargo new` or `cargo init` |
| `pubspec.yaml` | `flutter create` |
| `*.xcodeproj/*` | Xcode or `swift package init` |
| `project.pbxproj` | **NEVER TOUCH** - Xcode only |
| `.csproj` | `dotnet new` |
| `pom.xml` | `mvn archetype:generate` |

### Never Skip These Steps

```
❌ DON'T: Create project files manually
✅ DO: Use framework CLI (npx create-next-app, flutter create, cargo new)

❌ DON'T: Assume packages are installed
✅ DO: Run npm install / flutter pub get / cargo build after setup

❌ DON'T: Guess CLI availability
✅ DO: Check with --version first

❌ DON'T: Write code without reading existing files
✅ DO: Always Read before editing

❌ DON'T: Skip dependency installation
✅ DO: npm install, pip install, cargo build after adding deps

❌ DON'T: Forget post-edit verification
✅ DO: Run linters, tests, builds after changes
```

### Always Verify After Actions

```bash
# After creating web project
npm install && npm run dev  # Verify it starts

# After adding shadcn component
npx shadcn@latest add button  # Use CLI, don't copy files!

# After Flutter changes
flutter pub get && flutter analyze

# After Rust changes  
cargo check && cargo clippy

# After Go changes
go build ./... && go vet ./...

# After Python changes
pip install -e . && pytest
```